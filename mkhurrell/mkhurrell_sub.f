c    This code was written by Karl Taylor with light modifications made by
c    Stephen Po-Chedley to make it compatible with f2py
c        (notably, add intent to some solvmid subroutine arguments)
c    KT cleaned up code, comments were added for documentation, and
c        additional diagnostics are now returned (3 August 2019)
c    PJD added print statement to solvmid to test python console (22 Sept 2021)
c
c 34567812345678123456781234567812345678123456781234567812345678123456781234567890
c
c *********************************************************************
c
c  GENERAL PROGRAM DESCRIPTION
c
c *********************************************************************
c
c  Purpose:
c
c    to create an artificial mid-month sea ice fraction or SST data set (referred
c    to here as the "boundary condition data" set) that, when linearly
c    interpolated (in time) and possibly clipped so-as not to exceed physical
c    limits, produces the observed monthly means
c
c  REFERENCE:
c
c    Taylor, K.E., D. Williamson, and F. Zwiers (2000): The sea surface
c          temperature and sea-ice concentration boundary conditions for
c          AMIP II simulations. PCMDI Report No. 60 and UCRL-MI-125597,
c          Lawrence Livermore National Laboratory, Livermore, CA, 25 pp.
c
c    pdf file available at
c          https://pcmdi.llnl.gov/report/ab60.html
c
c  OVERVIEW OF ALGORITHM:
c
c     The following assumes familiarity with the information contained
c     in the reference listed above.
c
c        Away from regions of near-freezing temperature, the SSTs are
c     generated by solving a set of N linear equations where N
c     is the number of months considered. The mid-month (boundary
c     condition) temperatures for a given month depend on the observed
c     monthly-mean temperature of that month, and also the temperatures
c     of the preceeding month and following month. Thus, the mid-month
c     temperature for the first and last months formally require observed
c     temperatures before and after the time period considered. In practice
c     the dependence on the temperatures outside the period considered is
c     fairly weak. To close the problem mathematically, however, we must
c     impose some sort of condition on the temperatures before and following
c     the period of interest.
c
c        If observations are available for several months before and
c     after the period of interest, then these can be used along with
c     imposition of a periodic boundary condition to fully constrain the
c     problem. (By "periodic boundary condition," we mean that the first
c     month of the available observations is assumed to follow the last
c     month). The periodic boundary condition should only be imposed on an
c     observational period that comprises an integral number of years, so,
c     for example, if the first month is March, the last month must be
c     February.
c
c        Away from regions of near-freezing temperature, the mid-month
c     SSTs [represented here by S] satisfy:
c
c               A S = B
c
c      where S is a column vector of dimension N representing the mid-month
c           values that constitute the SST boundary condition, B is a column
c           vector of dimension N, representing the observed monthly mean
c           time-series, and A (except for 2 elements) is a tri-diagonal
c           matrix of dimension NxN. The two unconforming elements account
c           for the assumption of periodicity. (The following shows the
c           matrix structure.)
c
c          |bb(1) cc(1)              ...           aa(1) |
c          |aa(2) bb(2) cc(2)                            |
c          | .   aa(3) bb(3) cc(3)   ...                 |
c      A = |                   .                         |
c          |                   .                         |
c          |                   .                         |
c          |          ...         aa(N-1) bb(N-1) cc(N-1)|
c          |cc(N)     ...                  aa(N)   bb(N) |
c
c      where
c          aa(i) = a(i)/8
c          bb(i) = 1 - a(i)/8 - c(i)/8
c          cc(i) = c(i)/8
c
c          a(i) = 2*n(i)/(n(i)+n(i-1))
c          c(i) = 2*n(i)/(n(i)+n(i+1))
c
c      where n(i) = number of days in month i.
c
c     Note that if all the months were of equal length, then a=c=1
c          and aa=1/8, bb=3/4, and cc=1/8.
c
c        For sea ice, the above procedure has to be modified because the
c     sea ice fraction is constrained to be between 0 and 1. Similarly,
c     the water temperature cannot fall below its freezing point, so this
c     also places a physical constraint that is not always consistent with
c     the above procedure. In these cases the equations that must be solved
c     have a similar structure as shown above, but the coefficients
c     (aa's, bb's, and cc's) depend on temperature or the sea ice fraction.
c     Thus, the equations in this case are no longer linear, but they can be
c     solved using an iterative Newton-Raphson approach.
c
c     The Jacobian that is required under this approach is not generated
c     analytically, but is approximated numerically.
c
c     There is another constraint necessary to ensure a unique solution in
c     the nonlinear case. To see why the constraint is needed, consider a
c     grid cell where the ocean is ice-free year around, except for 1 month,
c     when the ice fraction is 10%. The mid-month value for this month is
c     not uniquely determined because the cell could be covered by little
c     ice over the entire month, or by lots of ice for only a short time in
c     the middle of the month. The algorithm relied on in this code tries
c     to minimize the absolute difference between mid-month values that
c     exceed the maximum physically allowed value (S_max=100% for sea ice)
c     and S_max, while still yielding the correct monthly means: i.e.,

c                 where S > S_max, minimize (S - S_max)

c     Similarly, for values that are less than the minimum physically
c     allowed value (S_min = 0% for sea ice):

c                 where S < S_min, minimize (S_min - S)

c     In the example above this results in the following mid-month values
c     for sea ice (assuming for simplicity that all months are of the same
c     length):  S(i-1) = S(i+1) = -20%  and  S(i) = 20%  where i is the
c     month with mean sea ice fraction of 10%. These mid-month values when
c     linearly interpolated give a sea ice fraction for month i that starts
c     at 0%, linearly grows to 20% at the middle of the month, and then
c     linearly decreases to 0% at the end of the month. For the month
c     preceeding and the month following month i, the linear interpolation
c     leads to negative values, but recall that the model's alogrithm will
c     "clip" these values, setting them to 0%.
c
c
c
c *********************************************************************
c
      subroutine solvmid(alon, alat, nmon, conv, dt, vmin, vmax,
     &     bbmin, maxiter, a, c, obsmean, ss, icnt, niter, notconverg,
     &     jj, resid, residmax, jumps, jcnt)
c
c *********************************************************************
c
c     Given the monthly mean time-series, solve for mid-month values that
c        when interpolated linearly in time reproduce the actual monthly means.
c
c      alat (in) = latitude of cell
c      alon (in) = longitude of cell
c      nmon (in) = length of time-series
c      conv (in) = maximum tolerated difference between true means and
c                      reconstructed means
c      dt (in) = observed data will be smoothed if the absolute difference between
c                consecutive values exceeds tmax-tmin-2*dt
c      tmin (in) = minimum physically realistic value; linearly interpolated
c                     values constructed from mid-month values are clipped so
c                     as not to be less than tmin.
c      tmax (in) = maximum physically realistic value; linearly interpolated
c                     values constructed from mid-month values are clipped so
c                     as not to exceed tmax.
c      bbmin (in) = minimum value tolerated for the diagonal of the Jacobian
c                      (currently bbmin is not used)
c      maxiter (in) = maximum number of iterations executed before giving up.
c      a(nmon) (in) = for 3 consecutive months, m-1, m, m+1, a(m) is the fraction
c              of the interval between the middle of month m-1 and month m that
c              lie within month m, multiplied by 2. For all m, a(m) approx. = 1.
c      c(nmon) (in) = for 3 consecutive months, m-1, m, m+1, c(m) is the fraction
c              of the interval between the middle of month m+1 and month m that
c              lie within month m, multiplied by 2. For all m, a(m) approx. = 1.
c      obsmean(nmon) (in) = vector of observed monthly-mean values
c              obsmean may be modified by this subroutine (if the time series
c              contains consecutive values that jump from near minimum to near
c              maximum values allowed, or vice versa). Calling code to check
c              that all tmin <= obsmean <= tmax for all months prior to execution.
c      ss(nmon)  (out) = monthly mid-month values
c      icnt (out) = number of jumps from max to min or min to max
c      niter (out) = maximum number of iterations required to converge
c                  (across all independent time segments in time-series)
c      notconverg (out) = # of segments where convergence cannot be achieved
c      jj (out) = number of isolated segments (separated by times when at least
c             two consecutive values are very near either the max or min allowed).
c             If there are no isolated segments, then time-series is assumed to
c               be cyclic and jj=0 is returned.
c             If all obsmean(n) are equal to tmin, jj=-2 is returned
c             If all obsmean(n) are equal to tmax, jj=-1 is returned
c      resid (out) = mean absolute difference between observed and reconstructed
c                          monthly means
c      residmax (out) = largest absolute difference between observed and
c                          reconstructed monthly means
c      jumps(nmon) (out) time (index) when obs values jump from one limit to
c                  the other
c      jcnt (inout) = accumulator counting number of cells where at least one
c                jump occurs.
c                Used in this subroutine to determine if diagnostics should be
c                printed).
c                *****  Python code should set jcnt to a negative integer before
c                *****  first calling solvmid
c
c   PJD 22 Nov 2021 - Updated for check inputs
c   PJD  2 Dec 2021 - Updated tmax/min -> vmax/min following hurrellfx.py

      implicit none
      integer nmon12
      parameter (nmon12=12)
      integer nmon, maxiter
      integer, intent(inout) :: jcnt
      integer, intent(out) :: icnt, niter, notconverg, jj
      integer, intent(out) :: jumps(nmon)
      real conv, vmin, vmax, dt, bbmin, alon, alat, dxm, dxp, s1, s2
      real obsmean(nmon), a(nmon), c(nmon)
      real, intent(out) :: ss(nmon)
      real, intent(out) :: resid, residmax
      integer i, n, imethod, n1, n2, i1, i2, i3, nnn, jend,
     &      kk, j, k, kkk, nm, np
      integer jbeg(nmon)
      real relax, residmax1, resid1, addmax, addmin
      real r(nmon), avg(nmon), aa(nmon), bb(nmon), cc(nmon),
     &     add(nmon)
      double precision s(nmon), sums
c
c     Check print statements are showing in python calling console
      print*, 'solvmid executing. alat:', alat, ' alon:', alon

c     Check inputs
      print*, "solvmid - j:", j, "alon:", alon, "i:", i, "alat:",
     & alat, "conv:", conv, "dt:", dt, "vmin:", vmin, "vmax:",
     & vmax, "bbmin:", bbmin, "maxiter:", maxiter, "jcnt:",
     & jcnt, 'nmon:', nmon
      print*, "len(aa):     ", size(aa)
      print*, "len(cc):     ", size(cc)
      print*, "len(obsmean):", size(obsmean)

c
c     set control on whether derivatives needed to compute jacobian will be
c        computed through an analytical approximation or by numerical
c        approximation. The first imethod-1 iterations the analytical
c        approximation will be invoked. If imethod < 1, then the numerical
c        approach will be used for all iterations
      imethod = 0
c
c ???  check following value
      relax = 1.0

c     Create new input for numer - 211102
c      delta = (tmax/tmin)/50

c
      niter = 0
      notconverg = 0
      resid = 0.
      residmax = 0.
      do 40, n=1,nmon
        jumps(n) = 0
        aa(n) = 1.e20
        bb(n) = 1.e20
        cc(n) = 1.e20
        ss(n) = obsmean(n)
        add(n) = 0.0
  40  continue

c
c    check for occurrence where obs monthly means are consecutively at upper
c      and lower limits. If so, smooth data, being careful to preserve annual
c      mean. Also initialize ss = obsmean
c
      if (jcnt .lt. 0) then
        jcnt = 0
        write(9,'("       lat    lon   #jumps   #iter  failed    ",
     &    "segs    resid  residmax     jump times")')
      endif

c
      n2 = nmon
      do 50 n=1,nmon
        n1 = n2
        n2 = n
        if ((obsmean(n2)-obsmean(n1)) .gt. (vmax-vmin-2.*dt)) then
          add(n1) = add(n1) +
     &           (0.5*(obsmean(n2)-obsmean(n1)-vmax+vmin) + dt)/c(n1)
          add(n2) = add(n2) -
     &           (0.5*(obsmean(n2)-obsmean(n1)-vmax+vmin) + dt)/a(n2)
        elseif ((obsmean(n1)-obsmean(n2)) .gt. (vmax-vmin-2.*dt)) then
          add(n1) = add(n1) -
     &           (0.5*(obsmean(n1)-obsmean(n2)-vmax+vmin) + dt)/c(n1)
          add(n2) = add(n2) +
     &           (0.5*(obsmean(n1)-obsmean(n2)-vmax+vmin) + dt)/a(n2)
        endif
   50 continue
c
      icnt = 0
      addmax = 0.0
      addmin = 0.0
      do 51 n=1,nmon
        if (add(n) .ne. 0.0) then
          jumps(icnt+1) = n
c          call errormsg1(jcnt, nmon, n, alon, alat, add(n),obsmean)
          addmax = amax1(addmax, add(n))
          addmin = amin1(addmin, add(n))
          obsmean(n) = obsmean(n) + add(n)
          icnt = icnt + 1
        endif
   51 continue
c
      if (icnt .gt. 0) then
        jcnt = jcnt + 1
c        call errormsg2(icnt, jcnt, alon, alat, addmax, addmin)
      endif
c
c    check if all are le tmin or all are ge tmax; if so set values and return
c
      if (obsmean(1) .le. (vmin+0.01*dt)) then
        do 80 i=2,nmon
          if (obsmean(i) .gt. (vmin+0.01*dt)) go to 99
   80   continue
c             All values are at tmin.
        do 85 i=1,nmon
          ss(i) = vmin
   85   continue
        jj=-2
        return
      elseif (obsmean(1) .ge. (vmax-0.01*dt)) then
        do 90 i=2,nmon
          if (obsmean(i) .lt. (vmax-0.01*dt)) go to 99
   90   continue
c             All values are at tmax.
        do 95 i=1,nmon
          ss(i) = vmax
   95   continue
        jj=-1
        return
      endif
c
c      Some values in the time series are between tmax and tmin.
c
   99 jj = 0
c     Find time intervals when there are two consecutive values less than
c            minimum followed by a value greater than maximum OR intervals
c            when there are two consecutive values greater than maximum
c            followed by a value less than maximum. The time series can be
c            broken into indpendent segments at points where consecutive max
c            or min values are found.
c            jbeg will point to the beginning of each of these segments.
      do 100 i=1,nmon
        i1 = i
        i2 = mod(i,nmon) + 1
        i3 = mod((i+1), nmon) + 1
        if (((obsmean(i1) .le. vmin+0.01*dt) .and.
     &       (obsmean(i2) .le. vmin+0.01*dt) .and.
     &       (obsmean(i3) .gt. vmin+0.01*dt)) .or.
     &      ((obsmean(i1) .ge. vmax-0.01*dt) .and.
     &       (obsmean(i2) .ge. vmax-0.01*dt) .and.
     &       (obsmean(i3) .lt. vmax-0.01*dt))) then
c         jj is counter for number of intervals satisfying criteria
          jj = jj + 1
          jbeg(jj) = i2
        endif
  100 continue
c
      if (jj .eq. 0) then
c
c        Begin simple cyclic treatment (i.e., time series considered to
c            represent a single period of a repeating cycle)
c
         nnn = 0
c        begin iteration procedure
  105    sums = 0.0d0
         residmax = 0.0

c         calc. latest approximation of means (given mid-month values)
c         also compute Jacobian
c
         do 110 n = 1, nmon
           nm = mod((n+nmon-2), nmon) + 1
           np = mod(n, nmon) + 1
           bb(n) = 0.0
           avg(n) = 0.0
           if (nnn .lt. imethod) then
             call approx(vmin, vmax, a(n), c(n), ss(nm), ss(n),
     &                ss(np), aa(n), bb(n), cc(n), avg(n))
           else
             call numer(conv, vmin, vmax, bbmin, a(n), c(n), ss(nm),
     &                ss(n), ss(np), aa(n), bb(n), cc(n), avg(n))
c             call numer(delta, tmin, tmax, bbmin, a(n), c(n), ss(nm),
c     &                ss(n), ss(np), aa(n), bb(n), cc(n), avg(n))
           endif
           r(n) = obsmean(n) - avg(n)
           sums = sums + abs(r(n))
           residmax = amax1(residmax, abs(r(n)))
  110    continue
         resid = real(sums)/nmon
c
         if (residmax .gt. conv) then
c
c          convergence not yet achieved
c
           if (nnn .gt. maxiter*0.95) then
             print*, 'iteration = ', nnn, ' residual = ', resid,
     &          ' maximum residual = ', residmax
           endif
           if (nnn .gt. maxiter*0.99) then
c             print*, ' '
c             print*, 'latitude = ', alat, ' longitude = ', alon
             do 115 n=1,nmon
               write(*,'(i5, 8(1pe10.2))') n, obsmean(n), avg(n), r(n),
     &              s(n), ss(n), aa(n), bb(n), cc(n)
  115        continue
           endif
c
           if (nnn .gt. maxiter) then
             notconverg = notconverg + 1
c             print*, 'latitude = ', alat, ' longitude = ', alon
c             print*, 'does not converge'
c             write(9,*) 'latitude = ', alat, ' longitude = ', alon
c             write(9,*) 'does not converge'
           else
c            solve for new estimate of mid-month values
             call cyclic(alon, alat, aa, bb, cc, cc(nmon), aa(1), r, s,
     &                nmon)
             do 120 n=1,nmon
               ss(n) = ss(n) + relax * real(s(n))
  120        continue
c            if ss exceeds tmax or tmin, then it should exceed it no
c                more than absolutely necessary:
c            replace original code with function:

c             Karl wanted to replace this and next (REPLACE START HERE),
c             but it wasn't working right
c             REPLACE START HERE
             do 130 n=1,nmon
               nm = mod((n+nmon-2), nmon) + 1
               np = mod(n, nmon) + 1
               if (ss(n) .gt. vmax) then
                 if (ss(nm) .le. vmax) then
                   dxm = (ss(n)-vmax)/((ss(n)-ss(nm))*a(n))
                 else
                   dxm = 0.0
                 endif
                 if (ss(np) .le. vmax) then
                   dxp = (ss(n)-vmax)/((ss(n)-ss(np))*c(n))
                 else
                   dxp = 0.0
                 endif
                 if ((dxm .gt. 0.5) .and. (dxp .gt. 0.5)) then
                   s1 = vmax + (vmax-ss(nm))*a(n)/(2.-a(n))
                   s2 = vmax + (vmax-ss(np))*c(n)/(2.-c(n))
                   ss(n) = amin1(s1, s2)
                 elseif ((dxm .eq. 0.0) .and. (dxp .eq. 0.0)) then
                   ss(n) = vmax
                 elseif ((dxp .eq. 0.0) .and. (dxm .gt. 0.5)) then
                   ss(n) = vmax + (vmax-ss(nm))*a(n)/(2.-a(n))
                 elseif ((dxm .eq. 0.0) .and. (dxp .gt. 0.5)) then
                   ss(n) = vmax + (vmax-ss(np))*c(n)/(2.-c(n))
                 endif
               elseif (ss(n) .lt. vmin) then
                 if (ss(nm) .ge. vmin) then
                   dxm = (ss(n)-vmin)/((ss(n)-ss(nm))*a(n))
                 else
                   dxm = 0.0
                 endif
                 if (ss(np) .ge. vmin) then
                   dxp = (ss(n)-vmin)/((ss(n)-ss(np))*c(n))
                 else
                   dxp = 0.0
                 endif
                 if ((dxm .gt. 0.5) .and. (dxp .gt. 0.5)) then
                   s1 = vmin + (vmin-ss(nm))*a(n)/(2.-a(n))
                   s2 = vmin + (vmin-ss(np))*c(n)/(2.-c(n))
                   ss(n) = amax1(s1, s2)
                 elseif ((dxm .eq. 0.0) .and. (dxp .eq. 0.0)) then
                   ss(n) = vmin
                 elseif ((dxp .eq. 0.0) .and. (dxm .gt. 0.5)) then
                   ss(n) = vmin + (vmin-ss(nm))*a(n)/(2.-a(n))
                 elseif ((dxm .eq. 0.0) .and. (dxp .gt. 0.5)) then
                   ss(n) = vmin + (vmin-ss(np))*c(n)/(2.-c(n))
                 endif
               endif
  130        continue
c             OLD CODE
c             do 130 n=1,nmon
c               nm = mod((n+nmon-2), nmon) + 1
c               np = mod(n, nmon) + 1
c               if (ss(n) .gt. tmax) then
c                 limit = 1
c                 CALL adjlimit(limit, tmax, a(n), c(n),
c     &                    ss(nm), ss(n), ss(np))
c               elseif (ss(n) .lt. tmin) then
c                 limit = 0
c                 CALL adjlimit(limit, tmin, a(n), c(n),
c     &                    ss(nm), ss(n), ss(np))
c               endif
c  130        continue
c            finished iteration
             nnn = nnn + 1
             go to 105
           endif
c
         endif
c
c        finished cyclic case
         niter = nnn
c
      else
c
c        treat independent segments
         do 300 j=1,jj
c
           jend = jbeg(j)
  150      jend = jend + 1
           i1 = mod((jend-1), nmon) + 1
           i2 = mod(jend, nmon) + 1
c             find end of interval that is independent of part of the
c                full time series.
           if (((obsmean(i1) .le. vmin+0.01*dt) .and.
     &          (obsmean(i2) .le. vmin+0.01*dt)) .or.
     &         ((obsmean(i1) .ge. vmax-0.01*dt) .and.
     &          (obsmean(i2) .ge. vmax-0.01*dt))) goto 204
            goto 150
c            calculate values for interval jbeg(j) to jend
c
c            latest approximation of means (given mid-month values)
  204        nnn = 0
c
c            begin iteration procedure
c
  205        kk = jend - jbeg(j) + 1
c
c            calculate jacobian and estimate of residual
c
             sums = 0.0d0
             residmax1 = 0.0
             do 210 k = 2, kk-1
               nm = mod((k+jbeg(j)-3), nmon) + 1
               n  = mod((k+jbeg(j)-2), nmon) + 1
               np = mod((k+jbeg(j)-1), nmon) + 1
               bb(k) = 0.0
               avg(k) = 0.0
               if (nnn .lt. imethod) then
                 call approx(vmin, vmax, a(n), c(n), ss(nm), ss(n),
     &                ss(np), aa(k), bb(k), cc(k), avg(k))
               else
                 call numer(conv, vmin, vmax, bbmin, a(n), c(n), ss(nm),
     &                ss(n), ss(np), aa(k), bb(k), cc(k), avg(k))
c                 call numer(delta, tmin, tmax, bbmin, a(n), c(n),
c     &                 ss(nm), ss(n), ss(np), aa(k), bb(k), cc(k),
c     &                 avg(k))
               endif
               r(k) = obsmean(n) - avg(k)
               sums = sums + abs(r(k))
               residmax1 = amax1(residmax1, abs(r(k)))



c           New diagnostics 210929
               if (((j .eq. 78) .and. (jbeg(j) .eq. 1274)) .or.
     &             ((j .eq. 107) .and.  (jbeg(j) .eq. 1730))) then
                 write(9, '(3(i6), 6(1pe12.2))')
     &                nnn, k, n, r(k), avg(k), obsmean(n), ss(n),
     &                aa(k), bb(k), cc(k)
               endif



  210        continue
             resid1 = real(sums)/(kk-2)
c
             if (residmax1 .gt. conv) then
c
c               convergence not yet achieved
c
c               if (nnn .gt. maxiter*0.9) then
c                  print*, 'iter = ', nnn, ' kk = ', kk, ' residual = ',
c     &               resid1, ' maximum residual = ', residmax1
c                  print*, ss(nm), ss(n), ss(np)
c               endif
               if (nnn .gt. maxiter*0.99)
     &           then
c                 print*, ' '
c                 print*, 'latitude = ', alat, ' longitude = ', alon
                 write(*,'(f8.1, i5, 2f8.1)') residmax1, nnn, alat, alon
c
                 n = jbeg(j)
                 avg(1) = obsmean(n)
                 r(1) = 0.0
                 n = mod((jend-1), nmon) + 1
                 avg(kk) = obsmean(n)
                 r(kk) = 0.0
c
                 do 215 k=1,kk
                   n  = mod((k+jbeg(j)-2), nmon) + 1
                   write(*,'(i5, 8(1pe10.2), i5, i5)') n, obsmean(n),
     &                  avg(k), r(k), s(k), ss(n), aa(k),
     &                  bb(k), cc(k), j, jj
  215            continue
               endif
c
               if (nnn .gt. maxiter) then
                 notconverg = notconverg + 1
c                 print*, 'latitude = ', alat, ' longitude = ', alon
c                 print*, 'does not converge'
c                 write(9,*) 'latitude = ', alat, ' longitude = ', alon
c                 write(9,*) 'does not converge'
               else
c                solve for new estimate of mid-month values
                 kkk = kk - 2
                 call tridag(alon, alat, aa(2), bb(2), cc(2), r(2),
     &                 s(2), kkk)
                 do 220 k=2,kk-1
                   n  = mod((k+jbeg(j)-2), nmon) + 1
                   ss(n) = ss(n) + relax * real(s(k))
  220            continue
c               if ss exceeds tmax or tmin, then it should exceed it no
c                    more than absolutely necessary:
c
c                treat first sample of segment:
c
                 n  = mod((jbeg(j)-1), nmon) + 1
                 np  = mod(jbeg(j), nmon) + 1
                 if (obsmean(n) .ge. (vmax-0.01*dt)) then
                   ss(n) =
     &                amax1(vmax, (vmax + (vmax-ss(np))*c(n)/(2.-c(n))))
                 else
                   ss(n) =
     &                amin1(vmin, (vmin + (vmin-ss(np))*c(n)/(2.-c(n))))
                 endif
c
c                treat last sample of segment:
c
                 nm  = mod((jend+nmon-2), nmon) + 1
                 n  = mod((jend-1), nmon) + 1
                 if (obsmean(n) .ge. (vmax-0.01*dt)) then
                   ss(n) =
     &                amax1(vmax, (vmax + (vmax-ss(nm))*a(n)/(2.-a(n))))
                 else
                   ss(n) =
     &                amin1(vmin, (vmin + (vmin-ss(nm))*a(n)/(2.-a(n))))
                 endif
c
c                if ss exceeds tmax or tmin, then it should exceed it no
c                more than absolutely necessary:
c                replace original code with function:
c
c                REPLACE START HERE
                 do 230 k=2,kk-1
                   nm = mod((k+jbeg(j)+nmon-3), nmon) + 1
                   n  = mod((k+jbeg(j)-2), nmon) + 1
                   np = mod((k+jbeg(j)-1), nmon) + 1
                   if (ss(n) .gt. vmax) then
                     if (ss(nm) .le. vmax) then
                       dxm = (ss(n)-vmax)/((ss(n)-ss(nm))*a(n))
                     else
                       dxm = 0.0
                     endif
                     if (ss(np) .le. vmax) then
                       dxp = (ss(n)-vmax)/((ss(n)-ss(np))*c(n))
                     else
                       dxp = 0.0
                     endif
                     if ((dxm .gt. 0.5) .and. (dxp .gt. 0.5)) then
                       s1 = vmax + (vmax-ss(nm))*a(n)/(2.-a(n))
                       s2 = vmax + (vmax-ss(np))*c(n)/(2.-c(n))
                       ss(n) = amin1(s1, s2)
                     elseif ((dxm .eq. 0.0) .and. (dxp .eq. 0.0)) then
                       ss(n) = vmax
                     elseif ((dxp .eq. 0.0) .and. (dxm .gt. 0.5)) then
                       ss(n) = vmax + (vmax-ss(nm))*a(n)/(2.-a(n))
                     elseif ((dxm .eq. 0.0) .and. (dxp .gt. 0.5)) then
                       ss(n) = vmax + (vmax-ss(np))*c(n)/(2.-c(n))
                     endif
                   elseif (ss(n) .lt. vmin) then
                     if (ss(nm) .ge. vmin) then
                       dxm = (ss(n)-vmin)/((ss(n)-ss(nm))*a(n))
                     else
                       dxm = 0.0
                     endif
                     if (ss(np) .ge. vmin) then
                       dxp = (ss(n)-vmin)/((ss(n)-ss(np))*c(n))
                     else
                       dxp = 0.0
                     endif
                     if ((dxm .gt. 0.5) .and. (dxp .gt. 0.5)) then
                       s1 = vmin + (vmin-ss(nm))*a(n)/(2.-a(n))
                       s2 = vmin + (vmin-ss(np))*c(n)/(2.-c(n))
                       ss(n) = amax1(s1, s2)
                     elseif ((dxm .eq. 0.0) .and. (dxp .eq. 0.0)) then
                       ss(n) = vmin
                     elseif ((dxp .eq. 0.0) .and. (dxm .gt. 0.5)) then
                       ss(n) = vmin + (vmin-ss(nm))*a(n)/(2.-a(n))
                     elseif ((dxm .eq. 0.0) .and. (dxp .gt. 0.5)) then
                       ss(n) = vmin + (vmin-ss(np))*c(n)/(2.-c(n))
                     endif
                   endif
  230            continue
c                OLD CODE HERE
c                 do 230 n=1,nmon
c                   nm = mod((n+nmon-2), nmon) + 1
c                   np = mod(n, nmon) + 1
c                   if (ss(n) .gt. tmax) then
c                     limit = 1
c                     CALL adjlimit(limit, tmax, a(n), c(n),
c     &                        ss(nm), ss(n), ss(np))
c                   elseif (ss(n) .lt. tmin) then
c                     limit = 0
c                     CALL adjlimit(limit, tmin, a(n), c(n),
c     &                    ss(nm), ss(n), ss(np))
c                   endif
c  230            continue
c                     finished iteration
                 nnn = nnn + 1
                 go to 205
               endif
c
             endif
c
            niter = max0(niter, nnn)
            resid = resid + real(sums)
            residmax = amax1(residmax, residmax1)



c           New diagnostics 210929
            i1 = mod(jbeg(j)-1, nmon) + 1
            i2 = min0( mod((kk-2+jbeg(j)), nmon) + 1, nmon)
            write(9, '(i6, i6, i6, i6, (1pe12.2))')
     &            j, jbeg(j), jend, kk, (ss(k), k=i1,i2)
            write(9, '(i6, (1pe12.2))')
     &            niter, resid, residmax, (avg(k), k=1,kk)
            write(9, '(i6, 2000(1pe12.2))')
     &            niter, residmax1, residmax, (obsmean(k), k=i1,i2)
c
c               write(*,'(i5, 8(1pe10.2))') n, obsmean(n), avg(n), r(n),
c     &              s(n), ss(n), aa(n), bb(n), cc(n)



c
c          300 finishes loop over independent segments.
  300    continue



c           New - attempt to flush the buffer 210929
            write(9,'((i6))') i, j



c
c        fill in values where consecutive means are outside limits
         do 250 i=1,nmon
           i1 = mod((i-2+nmon), nmon) + 1
           i2 = mod((i-1), nmon) + 1
           i3 = mod(i, nmon) + 1
           if ((obsmean(i1) .le. (vmin+0.01*dt)) .and.
     &         (obsmean(i2) .le. (vmin+0.01*dt)) .and.
     &         (obsmean(i3) .le. (vmin+0.01*dt))) then
             ss(i2) = vmin
           elseif ((obsmean(i1) .ge. (vmax-0.01*dt)) .and.
     &             (obsmean(i2) .ge. (vmax-0.01*dt)) .and.
     &             (obsmean(i3) .ge. (vmax-0.01*dt))) then
             ss(i2) = vmax
           endif
  250    continue
c
        resid = resid/nmon
c
c     end of if/else distinguishing between cyclic case and
c         independent segments case.
      endif
c
      if (notconverg .gt. 0) then
        write(9, '("***", f7.1, f7.1, i8, i8, i8, i8, 1pe12.2,
     &   1pe10.2, 3i6)')
     &       alat, alon, icnt, niter, notconverg, jj, resid, residmax,
     &         jumps(1), jumps(2), jumps(3)
      elseif (icnt .gt. 0) then
        write(9, '("   ", f7.1, f7.1, i8, i8, i8, i8, 1pe12.2,
     &   1pe10.2, 3i5)')
     &       alat, alon, icnt, niter, notconverg, jj, resid, residmax,
     &         jumps(1), jumps(2), jumps(3)
      endif
c
c      if (icnt .gt. 0) then
c        print*, 'icnt= ',icnt,'  jumps at times' ,(jumps(n), n=1,icnt)
c      endif
c
      return
      end
c
c
c *********************************************************************
c
      subroutine numer(delta, tmin, tmax, bbmin, a, c, ssm, ss, ssp, aa,
     &                 bb, cc, avg)
c
c *********************************************************************
c
c       numerically estimate jacobian elements: aa, bb, cc and compute the
c       mean (avg) for the month, based on the the current 3 mid-month values
c       (ssm, ss, and ssp) delta should be a small fraction of the range of
c       ss over all times
c
c       aa, bb, and cc, are partial derivatives of the change in the mean
c       over the central time, m, with respect to a change in the mid-month
c       values at times m-1, m, and m, respectively.
c
      implicit none
      real delta, tmin, tmax, bbmin, a, c, ssm, ss, ssp, aa, bb, cc, avg
      real ssmm, ssmp, sssm, sssp, sspm, sspp
      real amean
c
      avg = amean(tmin,tmax,a,c,ssm,ss,ssp)
      ssmm = ssm - delta
      ssmp = ssm + delta
      sssm = ss  - delta
      sssp = ss  + delta
      sspm = ssp - delta
      sspp = ssp + delta
c
      aa = (amean(tmin,tmax,a,c,ssmp,ss,ssp) -
     &      amean(tmin,tmax,a,c,ssmm,ss,ssp)) / (2.*delta)
      bb = (amean(tmin,tmax,a,c,ssm,sssp,ssp) -
     &      amean(tmin,tmax,a,c,ssm,sssm,ssp)) / (2.*delta)
      cc = (amean(tmin,tmax,a,c,ssm,ss,sspp) -
     &      amean(tmin,tmax,a,c,ssm,ss,sspm)) / (2.*delta)
c
c
C      The following was a part of the original code. Removed Aug 1, 2019.
C      It appeared to take longer to iterate.

c     New diagnostic code 210929
      if (bb .lt. bbmin) then
        bb = bbmin
C        r = 0.2*bbmin
C        aa = amax1(r, aa)
C        cc = amax1(r, cc)
      endif

c     the following ensures that the diagonal elements will dominate, and
c        that the matrix solver won't blow up, but it doesn't assure
c        optimal convergence speed.
c
      aa = amin1(aa, bb)
      cc = amin1(cc, bb)
c
      return
      end
c
c
c *********************************************************************
c
      subroutine approx(tmin, tmax, a, c, ssm, ss, ssp, aa, bb, cc, avg)
c
c *********************************************************************
c
c       calculate approximate jacobian elements: aa, bb, cc
c
      implicit none
      real tmin, tmax, a, c, ssm, ss, ssp, aa, bb, cc, avg
      real dx, dy
c
      if (ss .le.  tmin) then
c
c
        if (ssm .le. tmin) then
c
          avg = avg + tmin*0.5
          aa = a/32.
          bb = bb + 0.125 - a/32.
        elseif (ssm .ge. tmax) then
          dx = (ss-tmin)/((ss-ssm)*a)
          dy = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
            aa = a/32.
            bb = bb + 0.125 - a/32.
          elseif (dy .le. 0.5) then
            avg = avg + tmin*dx + tmax*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*a*(ss-ssm))
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        else
          dx = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
            aa = a/32.
            bb = bb + 0.125 - a/32.
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*a*(ss-ssm))
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        endif
c
        if (ssp .le. tmin) then
          avg = avg + tmin*0.5
          cc = c/32.
          bb = bb + 0.125 - c/32.
        elseif (ssp .ge. tmax) then
          dx = (ss-tmin)/((ss-ssp)*c)
          dy = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
            cc = c/32.
            bb = bb + 0.125 - c/32.
          elseif (dy .le. 0.5) then
            avg = avg + tmin*dx + tmax*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*c*(ss-ssp))
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
c
        else
c
          dx = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
            cc = c/32.
            bb = bb + 0.125 - c/32.
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*c*(ss-ssp))
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
        endif
c
c
      elseif (ss .ge. tmax) then
c
c
        if (ssm .ge. tmax) then
          avg = avg + tmax*0.5
          aa = a/32.
          bb = bb + 0.125 - a/32.
        elseif (ssm .le. tmin) then
          dx = (ss-tmax)/((ss-ssm)*a)
          dy = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
            aa = a/32.
            bb = bb + 0.125 - a/32.
          elseif (dy .le. 0.5) then
            avg = avg + tmax*dx + tmin*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*a*(ss-ssm))
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        else
          dx = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
            aa = a/32.
            bb = bb + 0.125 - a/32.
          else
            avg = avg +
     &        tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*a*(ss-ssm))
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        endif
c
        if (ssp .ge. tmax) then
          avg = avg + tmax*0.5
          cc = c/32.
          bb = bb + 0.125 - c/32.
        elseif (ssp .le. tmin) then
          dx = (ss-tmax)/((ss-ssp)*c)
          dy = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            cc = c/32.
            bb = bb + 0.125 - c/32.
            avg = avg + tmax*0.5
          elseif (dy .le. 0.5) then
            avg = avg + tmax*dx + tmin*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*c*(ss-ssp))
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
        else
          dx = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
            cc = c/32.
            bb = bb + 0.125 - c/32.
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*c*(ss-ssp))
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
        endif
c
c
      else
c
c         tmin < ss < tmax
c
        if (ssm .le. tmin) then
          dx = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          else
            avg = avg + tmin*(.5-dx) + dx*0.5*(tmin + ss)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        elseif (ssm .ge. tmax) then
          dx = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          else
            avg = avg + tmax*(.5-dx) + dx*0.5*(tmax + ss)
            aa = a/16.
            bb = bb + 0.25 - a/16.
          endif
        else
          avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
          aa = a/8.
          bb = bb + 0.5 - a/8.
        endif
c
        if (ssp .le. tmin) then
          dx = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          else
            avg = avg + tmin*(.5-dx) + dx*0.5*(tmin + ss)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
        elseif (ssp .ge. tmax) then
          dx = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          else
            avg = avg + tmax*(.5-dx) + dx*0.5*(tmax + ss)
            cc = c/16.
            bb = bb + 0.25 - c/16.
          endif
        else
          avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
          cc = c/8.
          bb = bb + 0.5 - c/8.
        endif
c
c
      endif
c
      return
      end
c
c
c *********************************************************************
c
      SUBROUTINE tridag(alon,alat,a,b,c,r,u,n)
c
c *********************************************************************
c
c     This code copied from Numerical Recipes for FORTRAN 77
c          see:
c      https://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf
c
      implicit none
      INTEGER n
      REAL alon,alat,a(n),b(n),c(n),r(n)
      double precision u(n)
      INTEGER j
      REAL bet, gam(n)
c
      if(b(1).eq.0.) then
c          print*, 'longitude = ', alon, '  latitude = ', alat
c          pause 'tridag: rewrite equations'
      endif
      bet=alat
      bet=alon
      bet=b(1)
      u(1)=r(1)/bet
c
      if (n .gt. 1) then
c
        do 11 j=2,n
          gam(j)=c(j-1)/bet
          bet=b(j)-a(j)*gam(j)
c          if(bet.eq.0.) then
c            print*, 'longitude = ', alon, '  latitude = ', alat
c            pause 'tridag failed'
c          endif
          u(j)=(r(j)-a(j)*u(j-1))/bet
11      continue
c
        do 12 j=n-1,1,-1
          u(j)=u(j)-gam(j+1)*u(j+1)
12      continue
c
      endif
c
      return
      END
c
c
c *********************************************************************
c
      SUBROUTINE cyclic(alon,alat,a,b,c,alpha,beta,r,x,n)
c
c *********************************************************************
c
c     This code copied from Numerical Recipes for FORTRAN 77
c          see:
c      https://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf
c
      implicit none
      INTEGER n
      real alon,alat,alpha,beta,a(n),b(n),c(n),r(n)
      double precision x(n)
CU    USES tridag
      INTEGER i
      REAL fact,gamma,bb(n),u(n)
      double precision z(n)
c
c      if(n.le.2)pause 'n too small in cyclic'
c      if(n.gt.nmax)pause 'nmax too small in cyclic'
      gamma=-b(1)
      bb(1)=b(1)-gamma
      bb(n)=b(n)-alpha*beta/gamma
      do 11 i=2,n-1
        bb(i)=b(i)
11    continue
c
      call tridag(alon,alat,a,bb,c,r,x,n)
c
      u(1)=gamma
      u(n)=alpha
      do 12 i=2,n-1
        u(i)=0.
12    continue
c
      call tridag(alon,alat,a,bb,c,u,z,n)
c
      fact=(real(x(1)) + beta * real(x(n))/gamma) /
     & (1.+real(z(1)) + beta * real(z(n))/gamma)
c
      do 13 i=1,n
        x(i)=x(i)-fact*z(i)
13    continue
c
      return
      END
c
c
c *********************************************************************
c
      function amean(tmin, tmax, a, c, ssm, ss, ssp)
c
c *********************************************************************
c
c     Given mid-month values for 3 adjacent time samples, computes the monthly
c           mean, being sure to clip values exceeding tmin and tmax limits
c
c   tmin (in) = physical lower limit on field (e.g., for sea ice fraction tmin=0.)
c   tmax (in) = physical upper limit on field (e.g., for sea ice tmax = 100%)
c   a (in) = for 3 consecutive months (say, 1, 2, and 3) "a" is the fraction of
c              of the interval between the middle of month 1 and month 2 that lie
c              within month 2, muliplied by 2. The a's are all about 1.
c   c (in) = for 3 consecutive months (say, 1, 2, and 3) "c" is the fraction of
c              the interval between the middle of month 2 and month 3 that lie
c              within month 2, muliplied by 2. The a's are all about 1.
c   ssm, ss, ssp (in) = mid-month values for 3 consecutive months.
c   amean (out) = value of function = monthly mean for month corresponding to ss.
c
      implicit none
      real amean
      real tmin, tmax, a, c, ssm, ss, ssp
      real dx, dy, avg
      avg = 0.0
      if (ss .le.  tmin) then
        if (ssm .le. tmin) then
          avg = avg + tmin*0.5
        elseif (ssm .ge. tmax) then
          dx = (ss-tmin)/((ss-ssm)*a)
          dy = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
          elseif (dy .le. 0.5) then
            avg = avg + tmin*dx + tmax*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*a*(ss-ssm))
          endif
        else
          dx = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*a*(ss-ssm))
          endif
        endif
        if (ssp .le. tmin) then
          avg = avg + tmin*0.5
        elseif (ssp .ge. tmax) then
          dx = (ss-tmin)/((ss-ssp)*c)
          dy = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
          elseif (dy .le. 0.5) then
            avg = avg + tmin*dx + tmax*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*c*(ss-ssp))
          endif
        else
          dx = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmin*0.5
          else
            avg = avg +
     &              tmin*dx + (0.5-dx)*0.5*(tmin + ss - 0.5*c*(ss-ssp))
          endif
        endif
      elseif (ss .ge. tmax) then
        if (ssm .ge. tmax) then
          avg = avg + tmax*0.5
        elseif (ssm .le. tmin) then
          dx = (ss-tmax)/((ss-ssm)*a)
          dy = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
          elseif (dy .le. 0.5) then
            avg = avg + tmax*dx + tmin*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*a*(ss-ssm))
          endif
        else
          dx = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
          else
            avg = avg +
     &        tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*a*(ss-ssm))
          endif
        endif
        if (ssp .ge. tmax) then
          avg = avg + tmax*0.5
        elseif (ssp .le. tmin) then
          dx = (ss-tmax)/((ss-ssp)*c)
          dy = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
          elseif (dy .le. 0.5) then
            avg = avg + tmax*dx + tmin*(.5-dy) + (dy-dx)*.5*(tmin+tmax)
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*c*(ss-ssp))
          endif
        else
          dx = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + tmax*0.5
          else
            avg = avg +
     &              tmax*dx + (0.5-dx)*0.5*(tmax + ss - 0.5*c*(ss-ssp))
          endif
        endif
      else
        if (ssm .le. tmin) then
          dx = (ss-tmin)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
          else
            avg = avg + tmin*(.5-dx) + dx*0.5*(tmin + ss)
          endif
        elseif (ssm .ge. tmax) then
          dx = (ss-tmax)/((ss-ssm)*a)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
          else
            avg = avg + tmax*(.5-dx) + dx*0.5*(tmax + ss)
          endif
        else
          avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssm)*a)
        endif
        if (ssp .le. tmin) then
          dx = (ss-tmin)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
          else
            avg = avg + tmin*(.5-dx) + dx*0.5*(tmin + ss)
          endif
        elseif (ssp .ge. tmax) then
          dx = (ss-tmax)/((ss-ssp)*c)
          if (dx .ge. 0.5) then
            avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
          else
            avg = avg + tmax*(.5-dx) + dx*0.5*(tmax + ss)
          endif
        else
          avg = avg + 0.5*0.5*(2.*ss - 0.5*(ss-ssp)*c)
        endif
      endif
      amean = avg
      return
      end
c
c
c *********************************************************************
c
      subroutine adjlimit(maxormin, tlimit, a, c, sm, s, sp)
c
c *********************************************************************
c
c     possibly modify mid-month values that exceed limits in an attempt to
c          minimize possibly exaggerated variance
c
c      maxormin = 0 implies we're treating case when the mid value
c                    is <= tmin
c      maxormin = 1 implies we're treating case when the mid value
c                    is >= tmax
c
      implicit none
c
c        function arguments
      integer maxormin
      real tlimit, a, c, sm, s, sp
c        local variables
      real s1, s2, dxm, dxp
c
c        calc. fraction of interval between central time and
c               previous time for which values exceed limit

      if (((maxormin .eq. 1) .and. (sm .le. tlimit)) .or.
     &   ((maxormin .eq. 0) .and. (sm .ge. tlimit)))  then
         dxm = (s-tlimit)/((s-sm)*a)
      else
         dxm = 0.0
      endif
c
c        calculate fraction of interval between central time and
c               following time for which values exceed limit
c
      if (((maxormin .eq. 1) .and. (sp .le. tlimit)) .or.
     &   ((maxormin .eq. 0) .and. (sp .ge. tlimit))) then
         dxp = (s-tlimit)/((s-sp)*c)
      else
         dxp = 0.0
      endif
c
c       calculate minimum mid-point value that will yield
c                 values exceeding limit over central time.
c
      if ((dxm .gt. 0.5) .and. (dxp .gt. 0.5)) then
c              values exceed limit over the entire interval
         s1 = tlimit + (tlimit-sm)*a/(2.-a)
         s2 = tlimit + (tlimit-sp)*c/(2.-c)
         if (maxormin .eq. 1) s = amin1(s1, s2)
         if (maxormin .eq. 0) s = amax1(s1, s2)
      elseif ((dxp .eq. 0.0) .and. (dxm .gt. 0.5)) then
c              value exceeds tmax at central time and previous time.
         s = tlimit + (tlimit-sm)*a/(2.-a)
      elseif ((dxm .eq. 0.0) .and. (dxp .gt. 0.5)) then
c              value exceeds tmax at central time and following time.
         s = tlimit + (tlimit-sp)*c/(2.-c)
      elseif ((dxm .eq. 0.0) .and. (dxp .eq. 0.0)) then
c           value exceeds tmax at central time and both neighbors
         s = tlimit
      endif
c
      return
      end
c
c
      subroutine errormsg1(jcnt, nmon, n, alon,alat, add, obsmean)
c
      implicit none
      integer jcnt, nmon, n
      real alon, alat, add
      real obsmean(nmon)
c
      integer n1, n2
c
           if (jcnt .lt. 5000) then
              print*, 'jump from extreme to extreme at time ', n
              write(9,*) 'jump from extreme to extreme at time ', n
           endif
           if (jcnt .eq. 5000) then
              print*, ' **********************************'
              print*, ' No more jump messages will be written'
              print*, ' **********************************'
           endif
           if (jcnt .lt. 5) then
          print*,
     &     'monthly means go from one limit to the other in 1 month'
          print*, 'alat = ', alat, ' alon = ', alon, ' n = ', n,
     &         ' add = ', add(n)
             n1 = mod((n+nmon-2), nmon) + 1
             n2 = mod(n, nmon) + 1
          print*, 'observed mean for 3 cells: ', obsmean(n1),
     &          obsmean(n), obsmean(n2)
           endif
          if (jcnt .le. 2)
     &        print*, (obsmean(n1), n1=1,nmon)
c
      return
      end
c
c
      subroutine errormsg2(icnt, jcnt, alon, alat, addmax, addmin)
c
      implicit none
      integer jcnt, icnt
      real alon, alat, addmax, addmin

        if (jcnt .le. 1000) then
          print*,  icnt,
     &      ' monthly values smoothed at lat,lon', alat, alon
          print*, 'max added = ', addmax,
     &             '  max subtracted = ', addmin
          write(9,*)  icnt,
     &      ' monthly values smoothed at lat,lon', alat, alon
          write(9,*) 'max added = ', addmax,
     &             '  max subtracted = ', addmin
        endif
        if (jcnt .eq. 50) then
          print*, ' '
          print*,
     &      'No more warnings will be printed concerning smoothing '//
     &       'of monthly data'
          print*, ' '
          write(9,*) ' '
          write(9,*)
     &      'No more warnings will be printed concerning smoothing '//
     &       'of monthly data'
          write(9,*) ' '
        endif
c
      return
      end
